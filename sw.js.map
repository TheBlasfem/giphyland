{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/js/sw/index.js","node_modules/serviceworker-cache-polyfill/index.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"sw.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","require('serviceworker-cache-polyfill');\nvar CACHE_NAME = 'giphyland-v1';\n\nvar urlsToCache = [\n  './',\n  '/css/all.css',\n  '/js/page.js'\n];\n\nself.addEventListener('install', function(event) {\n  event.waitUntil(\n    caches.open(CACHE_NAME)\n      .then(function(cache) {\n        return cache.addAll(urlsToCache);\n      })\n  );\n});","if (!Cache.prototype.add) {\n  Cache.prototype.add = function add(request) {\n    return this.addAll([request]);\n  };\n}\n\nif (!Cache.prototype.addAll) {\n  Cache.prototype.addAll = function addAll(requests) {\n    var cache = this;\n\n    // Since DOMExceptions are not constructable:\n    function NetworkError(message) {\n      this.name = 'NetworkError';\n      this.code = 19;\n      this.message = message;\n    }\n    NetworkError.prototype = Object.create(Error.prototype);\n\n    return Promise.resolve().then(function() {\n      if (arguments.length < 1) throw new TypeError();\n      \n      // Simulate sequence<(Request or USVString)> binding:\n      var sequence = [];\n\n      requests = requests.map(function(request) {\n        if (request instanceof Request) {\n          return request;\n        }\n        else {\n          return String(request); // may throw TypeError\n        }\n      });\n\n      return Promise.all(\n        requests.map(function(request) {\n          if (typeof request === 'string') {\n            request = new Request(request);\n          }\n\n          var scheme = new URL(request.url).protocol;\n\n          if (scheme !== 'http:' && scheme !== 'https:') {\n            throw new NetworkError(\"Invalid scheme\");\n          }\n\n          return fetch(request.clone());\n        })\n      );\n    }).then(function(responses) {\n      // TODO: check that requests don't overwrite one another\n      // (don't think this is possible to polyfill due to opaque responses)\n      return Promise.all(\n        responses.map(function(response, i) {\n          return cache.put(requests[i], response);\n        })\n      );\n    }).then(function() {\n      return undefined;\n    });\n  };\n}\n"]}